<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Jenas Datenbanksystem &apos;System J&apos;: DbjMemoryManager.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>DbjMemoryManager.cpp</h1><a href="_dbj_memory_manager_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*************************************************************************\</span>
00002 <span class="comment"> *                                                                       *</span>
00003 <span class="comment"> * (C) 2004-2005                                                         *</span>
00004 <span class="comment"> * Lehrstuhl fuer Datenbanken und Informationssysteme                    *</span>
00005 <span class="comment"> * Friedrich-Schiller-Universitaet Jena                                  *</span>
00006 <span class="comment"> * Ernst-Abbe-Platz 1-2                                                  *</span>
00007 <span class="comment"> * 07745 Jena                                                            *</span>
00008 <span class="comment"> *                                                                       *</span>
00009 <span class="comment">\*************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>     <span class="comment">// malloc(), free()</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>  <span class="comment">// ftok()</span>
00013 <span class="preprocessor">#include &lt;sys/ipc.h&gt;</span>    <span class="comment">// ftok(), shm*()</span>
00014 <span class="preprocessor">#include &lt;sys/shm.h&gt;</span>    <span class="comment">// shm*()</span>
00015 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>   <span class="comment">// S_I* Makros</span>
00016 <span class="preprocessor">#include &lt;errno.h&gt;</span>      <span class="comment">// errno</span>
00017 <span class="preprocessor">#include &lt;map&gt;</span>          <span class="comment">// STL map</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="_dbj_config_8hpp.html">DbjConfig.hpp</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="_dbj_memory_manager_8hpp.html">DbjMemoryManager.hpp</a>"</span>
00021 <span class="preprocessor">#undef new</span>
00022 <span class="preprocessor"></span>
00023 
00024 <span class="comment">// Komponente zu der der Memory Manager gehoert</span>
<a name="l00025"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a0">00025</a> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="_dbj_components_8hpp.html#a12">DbjComponent</a> <a class="code" href="_dbj_memory_manager_8cpp.html#a0">componentId</a> = <a class="code" href="_dbj_components_8hpp.html#a12a11">Support</a>;
00026 
00027 <span class="comment">// Marker vor/hinter den Speicherbloecken</span>
<a name="l00028"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a1">00028</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>[] = <span class="stringliteral">"deadbeefDEADBEEF"</span>;
00029 
00030 
00031 <span class="comment">// Informationen ueber die Stelle im Code an der ein Speicherblock</span>
00032 <span class="comment">// angefordert wurde; die Adresse des Speicherblocks ist _nach_ dem initialen</span>
00033 <span class="comment">// Marker!</span>
<a name="l00034"></a><a class="code" href="struct_memory_track_info.html">00034</a> <span class="keyword">struct </span><a class="code" href="struct_memory_track_info.html">MemoryTrackInfo</a>
00035 {
00036     <span class="comment">// Name der Datei, in der der Speicherblock angefordert wurde</span>
<a name="l00037"></a><a class="code" href="struct_memory_track_info.html#o0">00037</a>     <span class="keywordtype">char</span> <span class="keyword">const</span> *<a class="code" href="struct_memory_track_info.html#o0">fileName</a>;
00038     <span class="comment">// Zeilennummer in der Datei, wo der Speicherblock angefordert wurde</span>
<a name="l00039"></a><a class="code" href="struct_memory_track_info.html#o1">00039</a>     <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <a class="code" href="struct_memory_track_info.html#o1">lineNumber</a>;
00040     <span class="comment">// Name der Funktion, die den Speicherblock angefordert hat</span>
<a name="l00041"></a><a class="code" href="struct_memory_track_info.html#o2">00041</a>     <span class="keywordtype">char</span> <span class="keyword">const</span> *<a class="code" href="struct_memory_track_info.html#o2">function</a>;
00042     <span class="comment">// Groesse des Speicherblocks</span>
<a name="l00043"></a><a class="code" href="struct_memory_track_info.html#o3">00043</a>     <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <a class="code" href="struct_memory_track_info.html#o3">size</a>;
00044     <span class="comment">// Block/Adresse wurde 2x allokiert - ein Free wurde nicht erkannt</span>
<a name="l00045"></a><a class="code" href="struct_memory_track_info.html#o4">00045</a>     <span class="keywordtype">bool</span> <a class="code" href="struct_memory_track_info.html#o4">missedFree</a>;
00046 
00047     <span class="comment">// Konstruktor</span>
<a name="l00048"></a><a class="code" href="struct_memory_track_info.html#a0">00048</a>     <a class="code" href="struct_memory_track_info.html#a0">MemoryTrackInfo</a>() : <a class="code" href="struct_memory_track_info.html#o0">fileName</a>(NULL), <a class="code" href="struct_memory_track_info.html#o1">lineNumber</a>(0), <a class="code" href="struct_memory_track_info.html#o2">function</a>(NULL),
00049                         <a class="code" href="struct_memory_track_info.html#o3">size</a>(0), <a class="code" href="struct_memory_track_info.html#o4">missedFree</a>(false) { }
00050 };
00051 
00052 <span class="comment">// Function Object zum Vergleichen von 2 Zeigern</span>
<a name="l00053"></a><a class="code" href="struct_ptr_compare.html">00053</a> <span class="keyword">struct </span><a class="code" href="struct_ptr_compare.html">PtrCompare</a>
00054 {
<a name="l00055"></a><a class="code" href="struct_ptr_compare.html#a0">00055</a>     <span class="keywordtype">bool</span> <a class="code" href="struct_ptr_compare.html#a0">operator()</a>(<span class="keywordtype">void</span> <span class="keyword">const</span> *ptr1, <span class="keywordtype">void</span> <span class="keyword">const</span> *ptr2)<span class="keyword"> const</span>
00056 <span class="keyword">          </span>{ <span class="keywordflow">return</span> ptr1 &lt; ptr2; }
00057 };
00058 
00059 <span class="comment">// Function Object zum Allokieren von Speicher fuer die Alloc-Informationen</span>
00060 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00061"></a><a class="code" href="class_memory_track_allocator.html">00061</a> <span class="keyword">class </span><a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator</a> {
00062   <span class="keyword">public</span>:    
<a name="l00063"></a><a class="code" href="class_memory_track_allocator.html#w0">00063</a>     <span class="keyword">typedef</span> T <a class="code" href="class_memory_track_allocator.html#w0">value_type</a>;
<a name="l00064"></a><a class="code" href="class_memory_track_allocator.html#w1">00064</a>     <span class="keyword">typedef</span> size_t <a class="code" href="class_memory_track_allocator.html#w1">size_type</a>;
<a name="l00065"></a><a class="code" href="class_memory_track_allocator.html#w2">00065</a>     <span class="keyword">typedef</span> ptrdiff_t <a class="code" href="class_memory_track_allocator.html#w2">difference_type</a>;
<a name="l00066"></a><a class="code" href="class_memory_track_allocator.html#w3">00066</a>     <span class="keyword">typedef</span> T * <a class="code" href="class_memory_track_allocator.html#w3">pointer</a>;
<a name="l00067"></a><a class="code" href="class_memory_track_allocator.html#w4">00067</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T * <a class="code" href="class_memory_track_allocator.html#w4">const_pointer</a>;
<a name="l00068"></a><a class="code" href="class_memory_track_allocator.html#w5">00068</a>     <span class="keyword">typedef</span> T &amp; <a class="code" href="class_memory_track_allocator.html#w5">reference</a>;
<a name="l00069"></a><a class="code" href="class_memory_track_allocator.html#w6">00069</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T &amp; <a class="code" href="class_memory_track_allocator.html#w6">const_reference</a>;
00070 
<a name="l00071"></a><a class="code" href="class_memory_track_allocator.html#a0">00071</a>     <a class="code" href="class_memory_track_allocator.html#w3">pointer</a> <a class="code" href="class_memory_track_allocator.html#a0">address</a>(<a class="code" href="class_memory_track_allocator.html#w5">reference</a> obj)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;obj; }
<a name="l00072"></a><a class="code" href="class_memory_track_allocator.html#a1">00072</a>     <a class="code" href="class_memory_track_allocator.html#w4">const_pointer</a> <a class="code" href="class_memory_track_allocator.html#a0">address</a>(<a class="code" href="class_memory_track_allocator.html#w6">const_reference</a> obj)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;obj; }
00073 
<a name="l00074"></a><a class="code" href="class_memory_track_allocator.html#a2">00074</a>     <a class="code" href="class_memory_track_allocator.html#a2">MemoryTrackAllocator</a>() { }
<a name="l00075"></a><a class="code" href="class_memory_track_allocator.html#a3">00075</a>     <a class="code" href="class_memory_track_allocator.html#a2">MemoryTrackAllocator</a>(<span class="keyword">const</span>  <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;T&gt;</a>&amp;) { }
00076     <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00077"></a><a class="code" href="class_memory_track_allocator.html#a4">00077</a>     <a class="code" href="class_memory_track_allocator.html#a2">MemoryTrackAllocator</a>(<span class="keyword">const</span>  <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;U&gt;</a>&amp;) { }
<a name="l00078"></a><a class="code" href="class_memory_track_allocator.html#a5">00078</a>     <a class="code" href="class_memory_track_allocator.html#a5">~MemoryTrackAllocator</a>() { }
00079     <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00080"></a><a class="code" href="class_memory_track_allocator.html#a6">00080</a>     <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;T&gt;</a> &amp;<a class="code" href="class_memory_track_allocator.html#a6">operator=</a>(<span class="keyword">const</span>  <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;U&gt;</a>&amp;)
00081           { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
00082 
00083     <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00084"></a><a class="code" href="class_memory_track_allocator.html#a7">00084</a>     <a class="code" href="class_memory_track_allocator.html#w3">pointer</a> <a class="code" href="class_memory_track_allocator.html#a7">allocate</a>(<a class="code" href="class_memory_track_allocator.html#w1">size_type</a> n, U <span class="keyword">const</span> *)<span class="keyword"> const</span>
00085 <span class="keyword">          </span>{ <span class="keywordflow">return</span> static_cast&lt;pointer&gt;(malloc(n * <span class="keyword">sizeof</span>(T))); }
<a name="l00086"></a><a class="code" href="class_memory_track_allocator.html#a8">00086</a>     <a class="code" href="class_memory_track_allocator.html#w3">pointer</a> <a class="code" href="class_memory_track_allocator.html#a7">allocate</a>(<a class="code" href="class_memory_track_allocator.html#w1">size_type</a> n)<span class="keyword"> const</span>
00087 <span class="keyword">          </span>{ <span class="keywordflow">return</span> static_cast&lt;pointer&gt;(malloc(n * <span class="keyword">sizeof</span>(T))); }
<a name="l00088"></a><a class="code" href="class_memory_track_allocator.html#a9">00088</a>     <span class="keywordtype">void</span> <a class="code" href="class_memory_track_allocator.html#a9">deallocate</a>(<a class="code" href="class_memory_track_allocator.html#w3">pointer</a> ptr, <a class="code" href="class_memory_track_allocator.html#w1">size_type</a> <span class="comment">/* n */</span>) { free(ptr); }
00089 
<a name="l00090"></a><a class="code" href="class_memory_track_allocator.html#a10">00090</a>     <span class="keywordtype">void</span> <a class="code" href="class_memory_track_allocator.html#a10">construct</a>(<a class="code" href="class_memory_track_allocator.html#w3">pointer</a> ptr, T <span class="keyword">const</span> &amp;obj) { <span class="keyword">new</span>(ptr) T(obj); }
<a name="l00091"></a><a class="code" href="class_memory_track_allocator.html#a11">00091</a>     <span class="keywordtype">void</span> <a class="code" href="class_memory_track_allocator.html#a11">destroy</a>(<a class="code" href="class_memory_track_allocator.html#w3">pointer</a> ptr) { ptr-&gt;~T(); }
<a name="l00092"></a><a class="code" href="class_memory_track_allocator.html#a12">00092</a>     size_t <a class="code" href="class_memory_track_allocator.html#a12">max_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_memory_track_allocator.html#w1">size_type</a>(-1) / <span class="keyword">sizeof</span>(T); }
00093 
00094     <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00095"></a><a class="code" href="struct_memory_track_allocator_1_1rebind.html">00095</a>     <span class="keyword">struct </span><a class="code" href="struct_memory_track_allocator_1_1rebind.html">rebind</a> {
<a name="l00096"></a><a class="code" href="struct_memory_track_allocator_1_1rebind.html#w0">00096</a>         <span class="keyword">typedef</span> <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;U&gt;</a> <a class="code" href="class_memory_track_allocator.html">other</a>;
00097     };
00098 };
00099 
00100 <span class="comment">// Function Object zum Allokieren von "void" Objekten</span>
00101 <span class="keyword">template</span>&lt;&gt;
<a name="l00102"></a><a class="code" href="class_memory_track_allocator_3_01void_01_4.html">00102</a> <span class="keyword">class </span><a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator</a>&lt;void&gt; {
00103   <span class="keyword">public</span>:
<a name="l00104"></a><a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w0">00104</a>     <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w0">value_type</a>;
<a name="l00105"></a><a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w1">00105</a>     <span class="keyword">typedef</span> <span class="keywordtype">void</span> * <a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w1">pointer</a>;
<a name="l00106"></a><a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w2">00106</a>     <span class="keyword">typedef</span> <span class="keywordtype">void</span> <span class="keyword">const</span> * <a class="code" href="class_memory_track_allocator_3_01void_01_4.html#w2">const_pointer</a>;
00107     <span class="comment">// no references possible</span>
00108 
00109     <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00110"></a><a class="code" href="struct_memory_track_allocator_3_01void_01_4_1_1rebind.html">00110</a>     <span class="keyword">struct </span>rebind {
<a name="l00111"></a><a class="code" href="struct_memory_track_allocator_3_01void_01_4_1_1rebind.html#w0">00111</a>         <span class="keyword">typedef</span> <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator&lt;U&gt;</a> <a class="code" href="class_memory_track_allocator.html">other</a>;
00112     };
00113 };
00114 
00115 <span class="comment">// Datentyp zum Speichern der Informationen fuer die einzelnen Speicherbloecke</span>
00116 <span class="comment">// (wo genau allokiert?)</span>
00117 <span class="keyword">typedef</span> std::map&lt;<span class="keywordtype">void</span> <span class="keyword">const</span> *, <a class="code" href="struct_memory_track_info.html">MemoryTrackInfo</a>, <a class="code" href="struct_ptr_compare.html">PtrCompare</a>,
00118         <a class="code" href="class_memory_track_allocator.html">MemoryTrackAllocator</a>&lt;std::pair&lt;<span class="keywordtype">void</span> <span class="keyword">const</span> *,
<a name="l00119"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a2">00119</a>                 MemoryTrackInfo&gt; &gt; &gt; <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a>;
00120 
00121 
00122 <span class="comment">// Instanz des Memory Managers</span>
<a name="l00123"></a><a class="code" href="class_dbj_memory_manager.html#v1">00123</a> <a class="code" href="class_dbj_memory_manager.html">DbjMemoryManager</a> *<a class="code" href="class_dbj_memory_manager.html#v1">DbjMemoryManager::instance</a> = NULL;
00124 
00125 
00126 <span class="comment">// Optionen fuer die einzelnen Speicherbereiche</span>
<a name="l00127"></a><a class="code" href="class_dbj_memory_manager.html#v0">00127</a> <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">DbjMemoryManager::MemorySetAttributes</a> <a class="code" href="class_dbj_memory_manager.html#v0">DbjMemoryManager::setProperties</a>[] = {
00128     { <a class="code" href="class_dbj_memory_manager.html#w4w0">DbjMemoryManager::PrivatePool</a>, <span class="stringliteral">"Private Pool"</span>, <span class="keyword">false</span>, 0, -1, NULL },
00129     { <a class="code" href="class_dbj_memory_manager.html#w4w1">DbjMemoryManager::BufferPool</a>, <span class="stringliteral">"Buffer Pool"</span>, <span class="keyword">true</span>, DBJ_BUFFER_POOL_SIZE, -1, NULL },
00130     { <a class="code" href="class_dbj_memory_manager.html#w4w2">DbjMemoryManager::LockList</a>, <span class="stringliteral">"Lock List"</span>, <span class="keyword">true</span>, DBJ_LOCK_LIST_SIZE, -1, NULL }
00131 };
00132 
00133 
00134 <span class="comment">// Konstruktor</span>
<a name="l00135"></a><a class="code" href="class_dbj_memory_manager.html#d5">00135</a> <a class="code" href="class_dbj_memory_manager.html#d5">DbjMemoryManager::DbjMemoryManager</a>() : allocInfo(NULL)
00136 {
00137     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00138 
00139     <span class="keywordtype">char</span> <span class="keyword">const</span> *trackFile = getenv(<span class="stringliteral">"DBJ_MEMORY_TRACK"</span>);
00140     <span class="keywordflow">if</span> (trackFile != NULL &amp;&amp; *trackFile != <span class="charliteral">'\0'</span>) {
00141         <span class="comment">// allokiere Speicher</span>
00142         <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track = static_cast&lt;MemoryAllocInfoType *&gt;(
00143                 malloc(<span class="keyword">sizeof</span>(<a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a>)));
00144         <span class="keywordflow">if</span> (track) {
00145             <span class="comment">// rufe Konstruktor explizit</span>
00146             <span class="keyword">new</span>(track) <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a>(*track);
00147             <span class="comment">// jetzt haben wir eine initialisierte "map"</span>
00148             <a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a> = track;
00149         }
00150     }
00151 }
00152 
00153 <span class="comment">// Destruktor</span>
<a name="l00154"></a><a class="code" href="class_dbj_memory_manager.html#d6">00154</a> <a class="code" href="class_dbj_memory_manager.html#d6">DbjMemoryManager::~DbjMemoryManager</a>()
00155 {
00156     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00157 
00158     <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00159         static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00160 
00161     <span class="keywordflow">if</span> (track != NULL) {
00162         track-&gt;clear();
00163         <span class="keyword">delete</span> track;
00164         <a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a> = NULL;
00165     }
00166 }
00167 
00168 
00169 <span class="comment">// Lege Shared Memory Segment an</span>
<a name="l00170"></a><a class="code" href="class_dbj_memory_manager.html#a0">00170</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a0">DbjMemoryManager::createMemorySet</a>(MemorySet <span class="keyword">const</span> memorySet)
00171 {
00172     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00173     <span class="keywordtype">int</span> shmId = 0;
00174 
00175     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00176     <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(1, <span class="stringliteral">"Memory Set ID"</span>, memorySet);
00177 
00178     rc = <a class="code" href="class_dbj_memory_manager.html#d1">getShmId</a>(memorySet, shmId, <span class="keyword">true</span>);
00179     <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00180         <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00181         <span class="keywordflow">goto</span> cleanup;
00182     }
00183 
00184     <span class="comment">// stelle Verbindung zum Segment her und setze Marker</span>
00185     {
00186         <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *attributes = NULL;
00187         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *marker = NULL;
00188         <span class="keywordtype">void</span> *ptr = NULL;
00189         <span class="keywordtype">int</span> shmRc = 0;
00190 
00191         <span class="comment">// finde Properties fuer den anzulegenden Speicherbereich</span>
00192         rc = <a class="code" href="class_dbj_memory_manager.html#d2">getSetProperties</a>(memorySet, attributes);
00193         <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00194             <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00195             <span class="keywordflow">goto</span> cleanup;
00196         }
00197 
00198         ptr = shmat(shmId, NULL, 0);
00199         <span class="keywordflow">if</span> (ptr == reinterpret_cast&lt;void *&gt;(-1)) {
00200             <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a99">DBJ_MM_SHM_CONNECT_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00201                     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, errno, strerror(errno));
00202             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00203             <span class="keywordflow">goto</span> cleanup;
00204         }
00205 
00206         marker = static_cast&lt;unsigned char *&gt;(ptr);
00207         memcpy(marker, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>);
00208         marker += <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00209         marker += attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o3">size</a>;
00210         memcpy(marker, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>);
00211 
00212         <span class="comment">// trenne Verbindung zum Segment</span>
00213         shmRc = shmdt(ptr);
00214         <span class="keywordflow">if</span> (shmRc == -1) {
00215             <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a100">DBJ_MM_SHM_DISCONNECT_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00216                     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, errno, strerror(errno));
00217             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00218             <span class="keywordflow">goto</span> cleanup;
00219         }
00220     }
00221 
00222  cleanup:
00223     <span class="keywordflow">return</span> rc;
00224 }
00225 
00226 
00227 <span class="comment">// Gib Shared Memory Segment frei</span>
<a name="l00228"></a><a class="code" href="class_dbj_memory_manager.html#a1">00228</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a1">DbjMemoryManager::destroyMemorySet</a>(MemorySet <span class="keyword">const</span> memorySet)
00229 {
00230     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00231     <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *attributes = NULL;
00232     <span class="keywordtype">int</span> shmRc = 0;
00233 
00234     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00235     <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(1, <span class="stringliteral">"Memory Set ID"</span>, memorySet);
00236 
00237     rc = <a class="code" href="class_dbj_memory_manager.html#d2">getSetProperties</a>(memorySet, attributes);
00238     <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00239         <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00240         <span class="keywordflow">goto</span> cleanup;
00241     }
00242 
00243     <span class="keywordflow">if</span> (!attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o2">isShared</a>) {
00244         <a class="code" href="_dbj_error_8hpp.html#a1">DBJ_SET_ERROR</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>);
00245         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00246         <span class="keywordflow">goto</span> cleanup;
00247     }
00248 
00249     <span class="comment">// bestimme SHM ID wenn das Zerstoeren von einem anderen Prozess aus</span>
00250     <span class="comment">// initiiert wurde</span>
00251     <span class="keywordflow">if</span> (attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a> == -1) {
00252         rc = <a class="code" href="class_dbj_memory_manager.html#d1">getShmId</a>(memorySet, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>);
00253         <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00254             <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00255             <span class="keywordflow">goto</span> cleanup;
00256         }
00257     }
00258 
00259     <span class="comment">// gib Speicherbereich frei</span>
00260     shmRc = shmctl(attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, IPC_RMID, NULL);
00261     <span class="keywordflow">if</span> (shmRc != 0) {
00262         <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(10, <span class="stringliteral">"Rc von 'shmctl'"</span>, shmRc);
00263         <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(10, <span class="stringliteral">"Shm ID"</span>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>);
00264         <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(12, <span class="stringliteral">"errno"</span>, errno);
00265         <span class="keywordflow">if</span> (<a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>() &gt;= 0) {
00266             <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a98">DBJ_MM_SHM_DESTROY_WARN</a>,
00267                     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>,
00268                     errno, strerror(errno));
00269             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00270             <span class="keywordflow">goto</span> cleanup;
00271         }
00272     }
00273 
00274  cleanup:
00275     <span class="keywordflow">return</span> rc;
00276 }
00277 
00278 
00279 <span class="comment">// Verbinden zu einem Shared Memory Segment</span>
<a name="l00280"></a><a class="code" href="class_dbj_memory_manager.html#a2">00280</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a2">DbjMemoryManager::connectToMemorySet</a>(MemorySet <span class="keyword">const</span> setId,
00281         <span class="keywordtype">void</span> *&amp;address)
00282 {
00283     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00284     <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *attributes = NULL;
00285     <span class="keywordtype">void</span> *ptr = NULL;
00286 
00287     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00288     <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(1, <span class="stringliteral">"Memory Set ID"</span>, setId);
00289 
00290     <span class="comment">// ermittle SHM ID</span>
00291     rc = <a class="code" href="class_dbj_memory_manager.html#d2">getSetProperties</a>(setId, attributes);
00292     <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00293         <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00294         <span class="keywordflow">goto</span> cleanup;
00295     }
00296     <span class="keywordflow">if</span> (attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a> != NULL) {
00297         <a class="code" href="_dbj_error_8hpp.html#a3">DBJ_SET_ERROR_TOKEN2</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a102">DBJ_MM_SHM_ALREADY_ATTACHED</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00298                 attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>);
00299         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00300         <span class="keywordflow">goto</span> cleanup;
00301     }
00302     <span class="keywordflow">if</span> (attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a> &lt; 0) {
00303         rc = <a class="code" href="class_dbj_memory_manager.html#d1">getShmId</a>(setId, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>);
00304         <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00305             <a class="code" href="_dbj_error_8hpp.html#a2">DBJ_SET_ERROR_TOKEN1</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a101">DBJ_MM_SHM_NOT_EXISTS</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>);
00306             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00307             <span class="keywordflow">goto</span> cleanup;
00308         }
00309     }
00310 
00311     <span class="comment">// stelle Verbindung zum Segment her</span>
00312     ptr = shmat(attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, NULL, 0);
00313     <span class="keywordflow">if</span> (ptr == reinterpret_cast&lt;void *&gt;(-1)) {
00314         <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a99">DBJ_MM_SHM_CONNECT_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00315                 attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, errno, strerror(errno));
00316         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00317         <span class="keywordflow">goto</span> cleanup;
00318     }
00319     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a> = ptr;
00320 
00321     <span class="comment">// ueberspringe Marker fuer zurueckzugebenden Zeiger</span>
00322     {
00323         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *marker = static_cast&lt;unsigned char *&gt;(ptr);
00324         marker += <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00325         ptr = marker;
00326     }
00327     address = ptr;
00328 
00329     <span class="comment">// fuege Zeiger zur Track-Struktur hinzu</span>
00330     <span class="keywordflow">if</span> (<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a> != NULL) {
00331         <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00332             static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00333         MemoryTrackInfo &amp;trackInfo = (*track)[ptr];
00334         <span class="keywordflow">if</span> (trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> != NULL) {
00335             trackInfo.<a class="code" href="struct_memory_track_info.html#o4">missedFree</a> = <span class="keyword">true</span>;
00336         }
00337         trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> = __FILE__;
00338         trackInfo.<a class="code" href="struct_memory_track_info.html#o1">lineNumber</a> = __LINE__;
00339         trackInfo.<a class="code" href="struct_memory_track_info.html#o2">function</a> = __FUNCTION__;
00340         trackInfo.<a class="code" href="struct_memory_track_info.html#o3">size</a> = attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o3">size</a>;
00341 
00342         <span class="comment">// pruefe alle Marker</span>
00343         <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00344     }
00345 
00346  cleanup:
00347     <span class="keywordflow">return</span> rc;
00348 }
00349 
00350 
00351 <span class="comment">// Trennen der Verbindung zu einem Shared Memory Segment</span>
<a name="l00352"></a><a class="code" href="class_dbj_memory_manager.html#a3">00352</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a3">DbjMemoryManager::disconnectFromMemorySet</a>(MemorySet <span class="keyword">const</span> setId)
00353 {
00354     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00355     <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *attributes = NULL;
00356     <span class="keywordtype">int</span> shmRc = 0;
00357 
00358     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00359     <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(1, <span class="stringliteral">"Memory Set ID"</span>, setId);
00360 
00361     <span class="comment">// ermittle SHM ID</span>
00362     rc = <a class="code" href="class_dbj_memory_manager.html#d2">getSetProperties</a>(setId, attributes);
00363     <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00364         <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00365         <span class="keywordflow">goto</span> cleanup;
00366     }
00367     <span class="keywordflow">if</span> (attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a> == NULL) {
00368         <a class="code" href="_dbj_error_8hpp.html#a2">DBJ_SET_ERROR_TOKEN1</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a103">DBJ_MM_SHM_NOT_ATTACHED</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>);
00369         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00370         <span class="keywordflow">goto</span> cleanup;
00371     }
00372     <span class="keywordflow">if</span> (attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a> &lt; 0) {
00373         <a class="code" href="_dbj_error_8hpp.html#a2">DBJ_SET_ERROR_TOKEN1</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a101">DBJ_MM_SHM_NOT_EXISTS</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>);
00374         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00375         <span class="keywordflow">goto</span> cleanup;
00376     }
00377 
00378     <span class="comment">// ueberpruefe alle Marker</span>
00379     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00380 
00381     <span class="comment">// loese Verbindung vom Segment</span>
00382     shmRc = shmdt(attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a>);
00383     <span class="keywordflow">if</span> (shmRc == -1) {
00384         <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a100">DBJ_MM_SHM_DISCONNECT_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00385                 attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a>, errno, strerror(errno));
00386         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00387         <span class="keywordflow">goto</span> cleanup;
00388     }
00389 
00390     <span class="comment">// entferne Zeiger aus Track-Struktur</span>
00391     <span class="keywordflow">if</span> (<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a> != NULL) {
00392         <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00393             static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00394         <span class="keywordtype">char</span> <span class="keyword">const</span> *ptr = static_cast&lt;char const *&gt;(attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a>);
00395         ptr += <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00396         track-&gt;erase(ptr);
00397     }
00398 
00399     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o5">ptr</a> = NULL;
00400 
00401  cleanup:
00402     <span class="keywordflow">return</span> rc;
00403 }
00404 
00405 
00406 <span class="comment">// Speicherblock allokieren</span>
<a name="l00407"></a><a class="code" href="class_dbj_memory_manager.html#a4">00407</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a4">DbjMemoryManager::getMemoryBlock</a>(<a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> blockSize,
00408         <span class="keywordtype">void</span> *&amp;ptr, <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName, <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber,
00409         <span class="keywordtype">char</span> <span class="keyword">const</span> *function)
00410 {
00411     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00412     <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00413         static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00414 
00415     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00416     <a class="code" href="group__trace__def.html#ga6">DBJ_TRACE_NUMBER</a>(1, <span class="stringliteral">"Blockgroesse"</span>, blockSize);
00417 
00418     ptr = NULL;
00419     <span class="keywordflow">if</span> (blockSize &lt;= 0) {
00420         <a class="code" href="_dbj_error_8hpp.html#a2">DBJ_SET_ERROR_TOKEN1</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a94">DBJ_MM_ALLOC_FAIL</a>, blockSize);
00421         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00422         <span class="keywordflow">goto</span> cleanup;
00423     }
00424 
00425     ptr = malloc(blockSize + 2 * <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>);
00426     <span class="keywordflow">if</span> (ptr == NULL) {
00427         <a class="code" href="_dbj_error_8hpp.html#a2">DBJ_SET_ERROR_TOKEN1</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a94">DBJ_MM_ALLOC_FAIL</a>, blockSize);
00428         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00429         <span class="keywordflow">goto</span> cleanup;
00430     }
00431 
00432     <span class="comment">// set markers at beginning/end of memory block</span>
00433     {
00434         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *marker = static_cast&lt;unsigned char *&gt;(ptr);
00435         memcpy(marker, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>);
00436         marker += <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00437         ptr = marker;
00438         marker += blockSize;
00439         memcpy(marker, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>);
00440     }
00441 
00442     <span class="comment">// keep track of all allocated memory blocks</span>
00443     <span class="keywordflow">if</span> (track != NULL) {
00444         MemoryTrackInfo &amp;trackInfo = (*track)[ptr];
00445         <span class="keywordflow">if</span> (trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> != NULL) {
00446             trackInfo.<a class="code" href="struct_memory_track_info.html#o4">missedFree</a> = <span class="keyword">true</span>;
00447         }
00448         trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> = fileName;
00449         trackInfo.<a class="code" href="struct_memory_track_info.html#o1">lineNumber</a> = lineNumber;
00450         trackInfo.<a class="code" href="struct_memory_track_info.html#o2">function</a> = function;
00451         trackInfo.<a class="code" href="struct_memory_track_info.html#o3">size</a> = blockSize;
00452     }
00453 
00454  cleanup:
00455     <span class="keywordflow">return</span> rc;
00456 }
00457 
00458 
00459 <span class="comment">// Freigeben eines Speicherblocks</span>
<a name="l00460"></a><a class="code" href="class_dbj_memory_manager.html#a5">00460</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#a5">DbjMemoryManager::freeMemoryBlock</a>(<span class="keywordtype">void</span> *ptr,
00461         <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName, <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber, <span class="keywordtype">char</span> <span class="keyword">const</span> *function)
00462 {
00463     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00464     <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00465         static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00466 
00467     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00468 
00469     <span class="keywordflow">if</span> (ptr != NULL) {
00470         <span class="comment">// verify that we want to free a valid pointer</span>
00471         <span class="keywordflow">if</span> (track != NULL) {
00472             MemoryTrackInfo &amp;trackInfo = (*track)[ptr];
00473             <span class="keywordflow">if</span> (trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> == NULL) {
00474                 fprintf(stderr, <span class="stringliteral">"\nWARNING\n=======\n"</span>);
00475                 fprintf(stderr, <span class="stringliteral">"Attempting to free invalid address "</span>
00476                         DBJ_FORMAT_POINTER, ptr);
00477                 <span class="keywordflow">if</span> (fileName != NULL &amp;&amp; lineNumber &gt; 0) {
00478                     fprintf(stderr, <span class="stringliteral">" at %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a>,
00479                             fileName, lineNumber);
00480                     <span class="keywordflow">if</span> (function != NULL) {
00481                         fprintf(stderr, <span class="stringliteral">"\n\tFunction: %s"</span>, function);
00482                     }
00483                 }
00484                 fprintf(stderr, <span class="stringliteral">"\n=======\n\n"</span>);
00485                 fflush(stderr);
00486             }
00487             <span class="keywordflow">else</span> {
00488                 <span class="comment">// check begin &amp; end markers of memory block for</span>
00489                 <span class="comment">// over/underflows</span>
00490                 <a class="code" href="class_dbj_memory_manager.html#d4">checkMemoryBoundaries</a>(ptr, fileName, lineNumber);
00491 
00492                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *marker = static_cast&lt;unsigned char *&gt;(ptr);
00493                 marker -= <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00494                 free(marker);
00495             }
00496             <span class="comment">// keep track of all allocated memory blocks</span>
00497             track-&gt;erase(ptr);
00498         }
00499         <span class="keywordflow">else</span> {
00500             <span class="comment">// check begin marker of memory block for underflows</span>
00501             <span class="comment">// (we can't verify the end marker because we don't know the size</span>
00502             <span class="comment">//  of the memory block here)</span>
00503             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *marker = static_cast&lt;unsigned char *&gt;(ptr);
00504             marker -= <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>;
00505             <span class="keywordflow">if</span> (memcmp(marker, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00506                         <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>) != 0) {
00507                 fprintf(stderr, <span class="stringliteral">"\nWARNING\n=======\n"</span>);
00508                 fprintf(stderr, <span class="stringliteral">"Underflow of memory area at address "</span>
00509                         DBJ_FORMAT_POINTER <span class="stringliteral">" detected"</span>, ptr);
00510                 <span class="keywordflow">if</span> (fileName != NULL &amp;&amp; lineNumber &gt; 0) {
00511                     fprintf(stderr, <span class="stringliteral">" at %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a>,
00512                             fileName, lineNumber);
00513                     <span class="keywordflow">if</span> (function != NULL) {
00514                         fprintf(stderr, <span class="stringliteral">"\n\tFunction: %s"</span>, function);
00515                     }
00516                 }
00517                 fprintf(stderr, <span class="stringliteral">"\n=======\n\n"</span>);
00518                 fflush(stderr);
00519             }
00520             free(marker);
00521         }
00522     }
00523 
00524     <span class="keywordflow">return</span> rc;
00525 }
00526 
00527 
00528 <span class="comment">// Ersatz fuer "memmove"</span>
<a name="l00529"></a><a class="code" href="class_dbj_memory_manager.html#a6">00529</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#a6">DbjMemoryManager::memMove</a>(<span class="keywordtype">void</span> *destination, <span class="keywordtype">void</span> <span class="keyword">const</span> *source,
00530         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> numBytes)
00531 {
00532     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00533     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00534     memmove(destination, source, numBytes);
00535     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00536 }
00537 
00538 
00539 <span class="comment">// Ersatz fuer "memcopy"</span>
<a name="l00540"></a><a class="code" href="class_dbj_memory_manager.html#a7">00540</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#a7">DbjMemoryManager::memCopy</a>(<span class="keywordtype">void</span> *destination, <span class="keywordtype">void</span> <span class="keyword">const</span> *source,
00541         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> numBytes)
00542 {
00543     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00544     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00545     memcpy(destination, source, numBytes);
00546     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00547 }
00548 
00549 
00550 <span class="comment">// Ersatz fuer "memset"</span>
<a name="l00551"></a><a class="code" href="class_dbj_memory_manager.html#a8">00551</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#a8">DbjMemoryManager::memSet</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">char</span> <span class="keyword">const</span> fillChar,
00552         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> numBytes)
00553 {
00554     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00555     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00556     memset(ptr, fillChar, numBytes);
00557     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00558 }
00559 
00560 
00561 <span class="comment">// Ersatz fuer "memcmp"</span>
<a name="l00562"></a><a class="code" href="class_dbj_memory_manager.html#a9">00562</a> <a class="code" href="group__datatypes.html#ga2">DbjCompareResult</a> <a class="code" href="class_dbj_memory_manager.html#a9">DbjMemoryManager::memCompare</a>(<span class="keywordtype">void</span> <span class="keyword">const</span> *ptr1,
00563         <span class="keywordtype">void</span> <span class="keyword">const</span> *ptr2, <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> numBytes)
00564 {
00565     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00566     <a class="code" href="group__datatypes.html#ga2">DbjCompareResult</a> res = <a class="code" href="group__datatypes.html#gga2a39">DBJ_DIFFERS</a>;
00567     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00568     res = memcmp(ptr1, ptr2, numBytes) == 0 ? <a class="code" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a> : <a class="code" href="group__datatypes.html#gga2a39">DBJ_DIFFERS</a>;
00569     <a class="code" href="class_dbj_memory_manager.html#d3">checkAllMemoryBoundaries</a>();
00570     <span class="keywordflow">return</span> res;
00571 }
00572 
00573 
00574 <span class="comment">// Schreibe Memory-Track-Info</span>
<a name="l00575"></a><a class="code" href="class_dbj_memory_manager.html#a10">00575</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#a10">DbjMemoryManager::dumpMemoryTrackInfo</a>()<span class="keyword"> const</span>
00576 <span class="keyword"></span>{
00577     <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00578         static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00579     FILE *trackFile = NULL;
00580     <span class="keywordtype">bool</span> closeFile = <span class="keyword">false</span>;
00581     <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName = getenv(<span class="stringliteral">"DBJ_MEMORY_TRACK"</span>);
00582 
00583     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00584 
00585     <span class="keywordflow">if</span> (track == NULL) {
00586         <span class="keywordflow">goto</span> cleanup;
00587     }
00588     <span class="keywordflow">if</span> (fileName != NULL &amp;&amp; *fileName != <span class="charliteral">'\0'</span>) {
00589         <span class="keywordflow">if</span> (*fileName == <span class="charliteral">'s'</span>) {
00590             <span class="keywordflow">if</span> (<a class="code" href="group__string__def.html#ga0">DbjStringCompare</a>(fileName, <span class="stringliteral">"stderr"</span>) == <a class="code" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a>) {
00591                 trackFile = stderr;
00592             }
00593             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__string__def.html#ga0">DbjStringCompare</a>(fileName, <span class="stringliteral">"stdout"</span>) == <a class="code" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a>) {
00594                 trackFile = stdout;
00595             }
00596         }
00597         <span class="keywordflow">if</span> (trackFile == NULL) {
00598             trackFile = fopen(fileName, <span class="stringliteral">"a+"</span>);
00599             <span class="keywordflow">if</span> (!trackFile) {
00600                 <span class="keywordflow">goto</span> cleanup;
00601             }
00602             closeFile = <span class="keyword">true</span>;
00603         }
00604     }
00605 
00606     <span class="keywordflow">if</span> (track-&gt;size() &gt; 0) {
00607         MemoryAllocInfoType::iterator iter = track-&gt;begin();
00608         fprintf(trackFile, <span class="stringliteral">"\n"</span>);
00609         fprintf(trackFile, <span class="stringliteral">"==================================\n"</span>);
00610         fprintf(trackFile, <span class="stringliteral">"Currently allocated memory blocks:\n"</span>);
00611         fprintf(trackFile, <span class="stringliteral">"----------------------------------\n"</span>);
00612         <span class="keywordflow">while</span> (iter != track-&gt;end()) {
00613             <span class="comment">// dump info about this block</span>
00614             fprintf(trackFile, <span class="stringliteral">"Address "</span> DBJ_FORMAT_POINTER <span class="stringliteral">" ("</span>
00615                     <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a> <span class="stringliteral">" Bytes), allocated at %s:"</span>
00616                     <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a> <span class="stringliteral">"\n\tFunction: %s\n"</span>,
00617                     iter-&gt;first, iter-&gt;second.size,
00618                     iter-&gt;second.fileName, iter-&gt;second.lineNumber,
00619                     iter-&gt;second.function);
00620             <span class="keywordflow">if</span> (iter-&gt;second.missedFree) {
00621                 printf(<span class="stringliteral">"\t==&gt; A free operation on this block was missed "</span>
00622                         <span class="stringliteral">"by the Memory Manager !!!\n"</span>);
00623             }
00624 
00625             <span class="comment">// check for buffer over/underflows</span>
00626             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keyword">const</span> *marker =
00627                 static_cast&lt;unsigned char const *&gt;(iter-&gt;first);
00628             <span class="keywordflow">if</span> (memcmp(marker - <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00629                         <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>) != 0) {
00630                 fprintf(trackFile, <span class="stringliteral">"\t==&gt; Buffer underflow detected.\n"</span>);
00631             }
00632             <span class="keywordflow">if</span> (memcmp(marker + iter-&gt;second.size, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00633                         <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>) != 0) {
00634                 fprintf(trackFile, <span class="stringliteral">"\t==&gt; Buffer overflow detected.\n"</span>);
00635             }
00636 
00637             <span class="comment">// process the next memory block</span>
00638             iter++;
00639         }
00640         fprintf(trackFile, <span class="stringliteral">"==================================\n\n"</span>);
00641         fflush(trackFile);
00642     }
00643 
00644  cleanup:
00645     <span class="keywordflow">if</span> (trackFile != NULL &amp;&amp; closeFile) {
00646         fclose(trackFile);
00647     }
00648 }
00649 
00650 
00651 <span class="comment">// "new" Operator fuer Memory Manager selbst</span>
<a name="l00652"></a><a class="code" href="class_dbj_memory_manager.html#h0">00652</a> <span class="keywordtype">void</span> *<a class="code" href="class_dbj_memory_manager.html#h0">DbjMemoryManager::operator new</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc)
00653 {
00654     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00655     <span class="keywordflow">return</span> malloc(size);
00656 }
00657 
00658 
00659 <span class="comment">// "delete" Operator fuer Memory Manager selbst</span>
<a name="l00660"></a><a class="code" href="class_dbj_memory_manager.html#h1">00660</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#h1">DbjMemoryManager::operator delete</a>(<span class="keywordtype">void</span> *ptr)
00661 {
00662     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00663     <span class="keywordflow">return</span> free(ptr);
00664 }
00665 
00666 
00667 <span class="comment">// Ermittle ID eines Shared Memory Segments</span>
<a name="l00668"></a><a class="code" href="class_dbj_memory_manager.html#d1">00668</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#d1">DbjMemoryManager::getShmId</a>(MemorySet <span class="keyword">const</span> memorySet,
00669         <span class="keywordtype">int</span> &amp;shmId, <span class="keywordtype">bool</span> <span class="keyword">const</span> create)
00670 {
00671     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00672     <span class="keywordtype">char</span> <span class="keyword">const</span> *dbPath = NULL;
00673     key_t shmKey = -1;
00674     <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *attributes = NULL;
00675     <a class="code" href="group__int__datatypes.html#ga9">Uint16</a> flags = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
00676 
00677     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00678 
00679     <span class="comment">// setze Flags zum Anlegen des Segments</span>
00680     <span class="keywordflow">if</span> (create) {
00681         flags |= IPC_CREAT | IPC_EXCL;
00682     }
00683 
00684     <a class="code" href="group__trace__def.html#ga4">DBJ_TRACE_DATA2</a>(1, <span class="keyword">sizeof</span> memorySet, &amp;memorySet, <span class="keyword">sizeof</span> flags, &amp;flags);
00685 
00686     <span class="comment">// finde Properties fuer den Speicherbereich</span>
00687     rc = <a class="code" href="class_dbj_memory_manager.html#d2">getSetProperties</a>(memorySet, attributes);
00688     <span class="keywordflow">if</span> (rc != <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>) {
00689         <a class="code" href="_dbj_error_8hpp.html#a8">DBJ_TRACE_ERROR</a>();
00690         <span class="keywordflow">goto</span> cleanup;
00691     }
00692 
00693     <span class="comment">// ermittle "key" fuer den Shared Memory Bereich</span>
00694     dbPath = getenv(<span class="stringliteral">"DBJ_DATABASE_PATH"</span>);
00695     <span class="keywordflow">if</span> (dbPath == NULL) {
00696         dbPath = DBJ_DEFAULT_DATABASE_PATH;
00697     }
00698     shmKey = ftok(dbPath, memorySet);
00699     <span class="keywordflow">if</span> (shmKey == -1) {
00700         <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a96">DBJ_MM_SHM_CREATE_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00701                 memorySet, errno, strerror(errno));
00702         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00703         <span class="keywordflow">goto</span> cleanup;
00704     }
00705     <a class="code" href="group__trace__def.html#ga3">DBJ_TRACE_DATA1</a>(10, <span class="keyword">sizeof</span> shmKey, &amp;shmKey);
00706 
00707     <span class="comment">// ermittle ID (eventuell mit Anlegen des Segments)</span>
00708     shmId = shmget(shmKey, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o3">size</a> + 2 * <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00709             flags);
00710     <span class="keywordflow">if</span> (shmId &lt; 0) {
00711         <span class="keywordflow">if</span> (!create) {
00712             <a class="code" href="_dbj_error_8hpp.html#a4">DBJ_SET_ERROR_TOKEN3</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a97">DBJ_MM_SHM_GETID_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00713                     errno, strerror(errno));
00714             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00715         }
00716         <span class="keywordflow">else</span> {
00717             <a class="code" href="_dbj_error_8hpp.html#a5">DBJ_SET_ERROR_TOKEN4</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a96">DBJ_MM_SHM_CREATE_FAIL</a>, attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o1">name</a>,
00718                     memorySet, errno, strerror(errno));
00719             rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00720         }
00721         <span class="keywordflow">goto</span> cleanup;
00722     }
00723     <a class="code" href="group__trace__def.html#ga3">DBJ_TRACE_DATA1</a>(20, <span class="keyword">sizeof</span> shmId, &amp;shmId);
00724     attributes-&gt;<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o4">shmId</a> = shmId;
00725 
00726  cleanup:
00727     <span class="keywordflow">return</span> rc;
00728 }
00729 
00730 
00731 <span class="comment">// Hole Attribute fuer Speicherbereich</span>
<a name="l00732"></a><a class="code" href="class_dbj_memory_manager.html#d2">00732</a> <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> <a class="code" href="class_dbj_memory_manager.html#d2">DbjMemoryManager::getSetProperties</a>(MemorySet <span class="keyword">const</span> memorySet,
00733         <a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html">MemorySetAttributes</a> *&amp;attributes)<span class="keyword"> const</span>
00734 <span class="keyword"></span>{
00735     <a class="code" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> rc = <a class="code" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>;
00736     <span class="keywordtype">bool</span> foundSet = <span class="keyword">false</span>;
00737 
00738     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00739 
00740     <span class="keywordflow">for</span> (<a class="code" href="group__int__datatypes.html#ga15">Uint32</a> i = 0; i &lt; <span class="keyword">sizeof</span> <a class="code" href="class_dbj_memory_manager.html#v0">setProperties</a> /
00741              <span class="keyword">sizeof</span> <a class="code" href="class_dbj_memory_manager.html#v0">setProperties</a>[0]; i++) {
00742         <span class="keywordflow">if</span> (<a class="code" href="class_dbj_memory_manager.html#v0">setProperties</a>[i].<a class="code" href="struct_dbj_memory_manager_1_1_memory_set_attributes.html#o0">setId</a> == memorySet) {
00743             attributes = &amp;(<a class="code" href="class_dbj_memory_manager.html#v0">setProperties</a>[i]);
00744             foundSet = <span class="keyword">true</span>;
00745         }
00746     }
00747     <span class="keywordflow">if</span> (!foundSet) {
00748         <a class="code" href="_dbj_error_8hpp.html#a1">DBJ_SET_ERROR</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>);
00749         rc = <a class="code" href="_dbj_error_8hpp.html#a11">DbjGetErrorCode</a>();
00750         <span class="keywordflow">goto</span> cleanup;
00751     }
00752     <a class="code" href="group__trace__def.html#ga3">DBJ_TRACE_DATA1</a>(10, <span class="keyword">sizeof</span> *attributes, attributes);
00753 
00754  cleanup:
00755     <span class="keywordflow">return</span> rc;
00756 }
00757 
00758 
00759 <span class="comment">// Pruefe Speichergrenzen</span>
<a name="l00760"></a><a class="code" href="class_dbj_memory_manager.html#d3">00760</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#d3">DbjMemoryManager::checkAllMemoryBoundaries</a>()<span class="keyword"> const</span>
00761 <span class="keyword"></span>{
00762     <a class="code" href="group__trace__def.html#ga0">DBJ_TRACE_ENTRY</a>();
00763     <span class="keywordflow">if</span> (<a class="code" href="group__trace__def.html#ga2">DBJ_TRACE_ACTIVE</a>() &amp;&amp; <a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a> != NULL) {
00764         <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00765             static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00766         MemoryAllocInfoType::iterator iter = track-&gt;begin();
00767         <span class="keywordflow">while</span> (iter != track-&gt;end()) {
00768             <a class="code" href="class_dbj_memory_manager.html#d4">checkMemoryBoundaries</a>(iter-&gt;first);
00769             iter++;
00770         }
00771     }
00772 }
00773 
00774 
00775 <span class="comment">// Pruefe Speichergrenzen</span>
<a name="l00776"></a><a class="code" href="class_dbj_memory_manager.html#d4">00776</a> <span class="keywordtype">void</span> <a class="code" href="class_dbj_memory_manager.html#d4">DbjMemoryManager::checkMemoryBoundaries</a>(<span class="keywordtype">void</span> <span class="keyword">const</span> *ptr,
00777         <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName, <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber)<span class="keyword"> const</span>
00778 <span class="keyword"></span>{
00779     <a class="code" href="_dbj_memory_manager_8cpp.html#a2">MemoryAllocInfoType</a> *track =
00780         static_cast&lt;MemoryAllocInfoType *&gt;(<a class="code" href="class_dbj_memory_manager.html#r0">allocInfo</a>);
00781     <span class="keywordtype">bool</span> underflow = <span class="keyword">false</span>;
00782     <span class="keywordtype">bool</span> overflow = <span class="keyword">false</span>;
00783 
00784     <span class="keywordflow">if</span> (ptr == NULL) {
00785         <span class="keywordflow">return</span>;
00786     }
00787 
00788     MemoryTrackInfo &amp;trackInfo = (*track)[ptr];
00789     <span class="keywordflow">if</span> (trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a> == NULL) {
00790         <span class="keywordflow">return</span>;
00791     }
00792 
00793     <span class="comment">// pruefe Marker vor dem Block</span>
00794     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keyword">const</span> *marker = static_cast&lt;unsigned char const *&gt;(ptr);
00795     <span class="keywordflow">if</span> (memcmp(marker - <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00796                 <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>) != 0) {
00797         underflow = <span class="keyword">true</span>;
00798         fprintf(stderr, <span class="stringliteral">"\nWARNING\n=======\n"</span>);
00799         fprintf(stderr, <span class="stringliteral">"Buffer underflow of memory area at address "</span>
00800                 DBJ_FORMAT_POINTER <span class="stringliteral">" detected.\n"</span>, ptr);
00801         <span class="keywordflow">if</span> (fileName != NULL &amp;&amp; lineNumber &gt; 0) {
00802             fprintf(stderr, <span class="stringliteral">"\tDetected at: %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a> <span class="stringliteral">"\n"</span>,
00803                     fileName, lineNumber);
00804         }
00805         fprintf(stderr, <span class="stringliteral">"\tBlock was allocated at: %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a>
00806                 <span class="stringliteral">"\n\tFunction: %s\n"</span>, trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a>,
00807                 trackInfo.<a class="code" href="struct_memory_track_info.html#o1">lineNumber</a>, trackInfo.<a class="code" href="struct_memory_track_info.html#o2">function</a>);
00808         fprintf(stderr, <span class="stringliteral">"=======\n\n"</span>);
00809         fflush(stderr);
00810     }
00811 
00812     <span class="comment">// pruefe Marker hinter dem Block</span>
00813     <span class="keywordflow">if</span> (memcmp(marker + trackInfo.<a class="code" href="struct_memory_track_info.html#o3">size</a>, <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>,
00814                 <span class="keyword">sizeof</span> <a class="code" href="_dbj_memory_manager_8cpp.html#a1">DBJ_MEMORY_MARKER</a>) != 0) {
00815         overflow = <span class="keyword">true</span>;
00816         fprintf(stderr, <span class="stringliteral">"\nWARNING\n=======\n"</span>);
00817         fprintf(stderr, <span class="stringliteral">"Buffer overflow of memory area at address "</span>
00818                 DBJ_FORMAT_POINTER <span class="stringliteral">" detected.\n"</span>, ptr);
00819         <span class="keywordflow">if</span> (fileName != NULL &amp;&amp; lineNumber &gt; 0) {
00820             fprintf(stderr, <span class="stringliteral">"\tDetected at: %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a> <span class="stringliteral">"\n"</span>,
00821                     fileName, lineNumber);
00822         }
00823         fprintf(stderr, <span class="stringliteral">"\tBlock was allocated at: %s:"</span> <a class="code" href="group__string__def.html#ga12">DBJ_FORMAT_UINT32</a>
00824                 <span class="stringliteral">"\n\tFunction: %s\n"</span>, trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a>,
00825                 trackInfo.<a class="code" href="struct_memory_track_info.html#o1">lineNumber</a>, trackInfo.<a class="code" href="struct_memory_track_info.html#o2">function</a>);
00826         fprintf(stderr, <span class="stringliteral">"=======\n\n"</span>);
00827         fflush(stderr);
00828     }
00829 
00830     <span class="keywordflow">if</span> (underflow || overflow) {
00831         <a class="code" href="_dbj_error_8hpp.html#a4">DBJ_SET_ERROR_TOKEN3</a>(<a class="code" href="_dbj_error_codes_8hpp.html#a107a95">DBJ_MM_BUFFER_UNDER_OVERFLOW</a>, trackInfo.<a class="code" href="struct_memory_track_info.html#o0">fileName</a>,
00832                 trackInfo.<a class="code" href="struct_memory_track_info.html#o1">lineNumber</a>, trackInfo.<a class="code" href="struct_memory_track_info.html#o2">function</a>);
00833     }
00834 }
00835 
00836 
00837 <span class="comment">// Global ueberladener "new" Operator</span>
<a name="l00838"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a3">00838</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga7">operator new</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc)
00839 {
00840     <span class="keywordtype">void</span> *ptr = NULL;
00841     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00842             __FILE__, __LINE__, __FUNCTION__);
00843     <span class="keywordflow">return</span> ptr;
00844 }
00845 
00846 
00847 <span class="comment">// Global ueberladener "new[]" Operator</span>
<a name="l00848"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a4">00848</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga8">operator new[]</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc)
00849 {
00850     <span class="keywordtype">void</span> *ptr = NULL;
00851     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00852             __FILE__, __LINE__, __FUNCTION__);
00853     <span class="keywordflow">return</span> ptr;
00854 }
00855 
00856 
00857 <span class="comment">// Global ueberladener "new" Operator</span>
<a name="l00858"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a5">00858</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga7">operator new</a>(size_t size, std::nothrow_t <span class="keyword">const</span> &amp;) <span class="keywordflow">throw</span>()
00859 {
00860     <span class="keywordtype">void</span> *ptr = NULL;
00861     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00862             __FILE__, __LINE__, __FUNCTION__);
00863     <span class="keywordflow">return</span> ptr;
00864 }
00865 
00866 
00867 <span class="comment">// Global ueberladener "new[]" Operator</span>
<a name="l00868"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a6">00868</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga8">operator new[]</a>(size_t size, std::nothrow_t <span class="keyword">const</span> &amp;) <span class="keywordflow">throw</span>()
00869 {
00870     <span class="keywordtype">void</span> *ptr = NULL;
00871     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00872             __FILE__, __LINE__, __FUNCTION__);
00873     <span class="keywordflow">return</span> ptr;
00874 }
00875 
00876 
00877 <span class="comment">// Global ueberladener "new" Operator</span>
<a name="l00878"></a><a class="code" href="group__memory__functions.html#ga7">00878</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga7">operator new</a>(size_t size, <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName,
00879         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber, <span class="keywordtype">char</span> <span class="keyword">const</span> *function) <span class="keywordflow">throw</span> (std::bad_alloc)
00880 {
00881     <span class="keywordtype">void</span> *ptr = NULL;
00882     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00883             fileName, lineNumber, function);
00884     <span class="keywordflow">return</span> ptr;
00885 }
00886 
00887 
00888 <span class="comment">// Global ueberladener "new[]" Operator</span>
<a name="l00889"></a><a class="code" href="group__memory__functions.html#ga8">00889</a> <span class="keywordtype">void</span> *<a class="code" href="group__memory__functions.html#ga8">operator new[]</a>(size_t size, <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName,
00890         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber, <span class="keywordtype">char</span> <span class="keyword">const</span> *function) <span class="keywordflow">throw</span> (std::bad_alloc)
00891 {
00892     <span class="keywordtype">void</span> *ptr = NULL;
00893     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a4">getMemoryBlock</a>(size, ptr,
00894             fileName, lineNumber, function);
00895     <span class="keywordflow">return</span> ptr;
00896 }
00897 
00898 
00899 <span class="comment">// Global ueberladener "delete" Operator</span>
<a name="l00900"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a9">00900</a> <span class="keywordtype">void</span> <a class="code" href="group__memory__functions.html#ga11">operator delete</a>(<span class="keywordtype">void</span> *ptr)
00901 {
00902     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a5">freeMemoryBlock</a>(ptr);
00903 }
00904 
00905 
00906 <span class="comment">// Global ueberladener "delete" Operator</span>
<a name="l00907"></a><a class="code" href="_dbj_memory_manager_8cpp.html#a10">00907</a> <span class="keywordtype">void</span> <a class="code" href="group__memory__functions.html#ga12">operator delete[]</a>(<span class="keywordtype">void</span> *ptr)
00908 {
00909     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a5">freeMemoryBlock</a>(ptr);
00910 }
00911 
00912 
00913 <span class="comment">// Global ueberladener "delete" Operator</span>
<a name="l00914"></a><a class="code" href="group__memory__functions.html#ga11">00914</a> <span class="keywordtype">void</span> <a class="code" href="group__memory__functions.html#ga11">operator delete</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName,
00915         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber, <span class="keywordtype">char</span> <span class="keyword">const</span> *function) <span class="keywordflow">throw</span>()
00916 {
00917     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a5">freeMemoryBlock</a>(ptr,
00918             fileName, lineNumber, function);
00919 }
00920 
00921 
00922 <span class="comment">// Global ueberladener "delete" Operator</span>
<a name="l00923"></a><a class="code" href="group__memory__functions.html#ga12">00923</a> <span class="keywordtype">void</span> <a class="code" href="group__memory__functions.html#ga12">operator delete[]</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">char</span> <span class="keyword">const</span> *fileName,
00924         <a class="code" href="group__int__datatypes.html#ga15">Uint32</a> <span class="keyword">const</span> lineNumber, <span class="keywordtype">char</span> <span class="keyword">const</span> *function) <span class="keywordflow">throw</span>()
00925 {
00926     <a class="code" href="class_dbj_memory_manager.html#e0">DbjMemoryManager::getMemoryManager</a>()-&gt;<a class="code" href="class_dbj_memory_manager.html#a5">freeMemoryBlock</a>(ptr,
00927             fileName, lineNumber, function);
00928 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Jul 4 15:40:29 2005 for Jenas Datenbanksystem 'System J' by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
