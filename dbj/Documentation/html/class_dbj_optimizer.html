<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Jenas Datenbanksystem &apos;System J&apos;: DbjOptimizer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>DbjOptimizer Class Reference</h1>Optimizer.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_dbj_optimizer_8hpp-source.html">DbjOptimizer.hpp</a>&gt;</code>
<p>
<a href="class_dbj_optimizer-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#a0">optimize</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;accessPlan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimiere Zugriffsplan.  <a href="#a0"></a><br></td></tr>
<tr><td colspan=2><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#y3">TruthValue</a> { <a class="el" href="class_dbj_optimizer.html#y3y0">AlwaysTrue</a>, 
<a class="el" href="class_dbj_optimizer.html#y3y1">AlwaysFalse</a>, 
<a class="el" href="class_dbj_optimizer.html#y3y2">Undetermined</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wahrheitswerte fuer Praedikate.  <a href="#y3">More...</a><br></td></tr>
<tr><td colspan=2><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d0">annotate</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;accessPlan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Annotiere Zugriffsplan.  <a href="#d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d1">annotateTableNode</a> (<a class="el" href="class_dbj_access_plan_table.html">DbjAccessPlanTable</a> *plan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Annotiere Table Knoten.  <a href="#d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d2">nestAndOrCombinations</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *predicate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loese AND/OR auf.  <a href="#d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d3">eliminateExcessiveNesting</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *predicate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eliminiere Schachtelungen.  <a href="#d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d4">removeAllNegations</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *predicates)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entferne Negationen.  <a href="#d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d5">resolveNegation</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *negation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loese eine Negation auf.  <a href="#d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d6">sortPredicatesToTables</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *predicates)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sortiere Praedikate zu Tabellen.  <a href="#d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d7">getAccessedTable</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *predicate, <a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;table) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ermittle genutzte Tabellen.  <a href="#d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d8">eliminateConstantPredicates</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *predicate, <a class="el" href="class_dbj_optimizer.html#y3">TruthValue</a> &amp;truthValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eliminiere Konstante Praedikate.  <a href="#d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d9">getTruthValue</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *predicate, <a class="el" href="class_dbj_optimizer.html#y3">TruthValue</a> &amp;truthValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ermittle den Wahrheitswert eines simplen Praedikats.  <a href="#d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d10">findIndexScans</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *tableList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finde moegliche Index-Scans.  <a href="#d10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d11">findIndexForPredicate</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *predicate, <a class="el" href="class_dbj_access_plan_index.html">DbjAccessPlanIndex</a> *&amp;indexNode, bool &amp;used)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finde Index fuer Praedikat.  <a href="#d11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d12">sortTableList</a> (<a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;tableList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sortiert die Tabellen im SELECT.  <a href="#d12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#d13">getTupleCount</a> (<a class="el" href="class_dbj_access_plan_table.html">DbjAccessPlanTable</a> const *tableNode, <a class="el" href="group__int__datatypes.html#ga15">Uint32</a> &amp;tupleCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hole Anzahl der Tupel.  <a href="#d13"></a><br></td></tr>
<tr><td colspan=2><br><h2>Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="group__int__datatypes.html#ga3">Uint8</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#v0">AND</a> = 0x01</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag fuer "AND"-Verknuepfung.  <a href="#v0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="group__int__datatypes.html#ga3">Uint8</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_dbj_optimizer.html#v1">OR</a> = 0x02</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag fuer "OR"-Verknuepfung.  <a href="#v1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Optimizer. 
<p>
Der Optimizer erhaelt den von <a class="el" href="class_dbj_compiler.html">DbjCompiler</a> geparsten und anschliessend validierten Ausfuehrungsplan und fuehrt einige regelbasierte Optimierungen auf diesen Plan durch. Optimierungen erfolgen nur fuer SELECT und DELETE Anweisungen. Alle anderen Answeisungen werden unveraendert zurueckgegeben.<p>
Fuer zu optimierende Anweisungen werden folgende Aenderungen des Planes in Betracht gezogen:<ol>
<li>Negationen werden in der WHERE-Klausel entfernt und die WHERE-Klausel wird normalisiert.</li><li>Selektionen werden vor Joins ausgefuehrt wenn ein Praedikat in der WHERE-Klausel sich ausschliesslich auf eine Tabelle bezieht.<br>
 Man beachte, dass "Tabelle" sich dabei auch auf Zwischentabellen beziehen kann, wenn mehr als ein Join durchzufuehren ist. So kann und sollte in der Anweisung "SELECT * FROM t1, t2, t3 WHERE t1.c1 = 1 AND t1.c2 = t2.c2" das Praedikat "t1.c1 = 1" vor allen Joins evaluiert werden, und das Praedikat "t1.c2 = t2.c2" nach dem Join der Tabellen "t1" und "t2" aber vor dem Join mit "t3" Anwendung finden.</li><li>Verwenden eines Index-Scans anstatt eines Table-Scans wenn in ein entsprechendes Praedikat in der WHERE-Klausel gefunden wird</li><li>Umsortieren von Tabellen in der FROM-Klausel von SELECT Answeisungen, und zwar so, dass die Tabelle mit der geringeren Anzahl von Tupeln (siehe Kataloginformationen der Klasse <a class="el" href="class_dbj_catalog_manager.html">DbjCatalogManager</a>) als innere Tabelle in einem "nested loop join" verwendet wird </li></ol>

<p>
Definition at line <a class="el" href="_dbj_optimizer_8hpp-source.html#l00048">48</a> of file <a class="el" href="_dbj_optimizer_8hpp-source.html">DbjOptimizer.hpp</a>.<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="y3" doxytag="DbjOptimizer::TruthValue" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="class_dbj_optimizer.html#y3">DbjOptimizer::TruthValue</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wahrheitswerte fuer Praedikate. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="y3y0" doxytag="AlwaysTrue" ></a>AlwaysTrue</em>&nbsp;</td><td>
Praedikat ist immer "wahr". </td></tr>
<tr><td valign=top><em><a class="anchor" name="y3y1" doxytag="AlwaysFalse" ></a>AlwaysFalse</em>&nbsp;</td><td>
Praedikat ist immer "falsch". </td></tr>
<tr><td valign=top><em><a class="anchor" name="y3y2" doxytag="Undetermined" ></a>Undetermined</em>&nbsp;</td><td>
Ergebnis des Praedikats ist erst zur Laufzeit bekannt. </td></tr>
</table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8hpp-source.html#l00138">138</a> of file <a class="el" href="_dbj_optimizer_8hpp-source.html">DbjOptimizer.hpp</a>.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d0" doxytag="DbjOptimizer::annotate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::annotate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>accessPlan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Annotiere Zugriffsplan. 
<p>
Der Zugriffsplan, wie er vom Compiler (<a class="el" href="class_dbj_compiler.html">DbjCompiler</a>) generiert wurde, umfasst alle Informationen ueber die verwendeten Tabellen und Spalten. Fuer die Tabellen und Spalten wurden beim Validieren (<a class="el" href="class_dbj_compiler.html#a3">DbjCompiler::validatePlan</a>) bereits die internen IDs ueber den Katalog herausgesucht und fuer die jeweiligen Knoten als Integer-Werte hinzugefuegt.<p>
Damit der Optimizer besser entscheiden kann, welcher endgueltige Plan zu verwenden ist, benoetigt er noch Informationen, welche Indexe auf den Tabellen existieren. Die Methode "annotate" nimmt diese Annotationen vor, d.h. es wird der Datenbank-Katalog konsultiert und alle Indexe zu allen Tabellen im Statement werden geholt und in den Zugriffsplan eingebaut. Anschliessend bestimmt der Optimizer, ob ein Index-Zugriff erfolgt (anstatt eines Table-Scans) und welcher Index dafuer verwendet werden soll.<p>
Im folgenden sind ein paar Beispiele fuer annotierte Ausfuehrungsplaene ausgelistet. Die zusaetzlichen Elemente (Knoten) im Ausfuehrungsplan sind <em>kursiv</em> gesetzt.<p>
<ul>
<li><b>CREATE TABLE</b> (bleibt unveraendert) <pre>
 CreateTableStmt
     |
   Table - Column (primary key)
     |
  Column - Column - ...
     |        |
     |     DataType - NotNullOption
     |
 DataType - NotNullOption
 </pre></li></ul>
<p>
<ul>
<li><b>DROP TABLE</b> (die Liste der Indexe auf der Tabelle wird angehaengt; diese Indexe muessen von der RunTime mit geloescht werden) <pre>
 DropTableStmt
     |
   Table - <em>Index</em> - <em>Index</em> - ...
 </pre></li></ul>
<p>
<ul>
<li><b>CREATE INDEX</b> (bleibt unveraendert) <pre>
 CreateIndexStmt
     |
   Index/UniqueIndex
     |
   Table
     |
  Column
     |
 IndexType
 </pre></li></ul>
<p>
<ul>
<li><b>DROP INDEX</b> (bleibt unveraendert) <pre>
 DropIndexStmt
     |
   Index
 </pre></li></ul>
<p>
<ul>
<li><b>INSERT</b> (die Liste der Indexe auf der Tabelle wird angehaengt; diese Indexe muessen mit gewartet werden, d.h. die jeweiligen Werte sind dort von der RunTime mit einzufuegen) <pre>
 InsertStmt
     |
  Sources - Table - <em>Index</em> - <em>Index</em> - ...
     |
    Row  -  Row
     |       |
     |     Value - Value - Value - ...
     |
   Value - Value - Value - ...
 </pre></li></ul>
<p>
<ul>
<li><b>UPDATE</b> (Die Liste der Indexe auf der Tabelle wird angehaengt; diese Indexe muessen mit gewartet werden, d.h. die jeweiligen Eintraege sind dort von der RunTime zu aktualisieren.) <pre>
 UpdateStmt
     |
  Sources - Table - <em>Index</em> - <em>Index</em> - ...
     |
 Assignments - Column - Value - ...
     |
 WhereClause - &lt;where-clause&gt;
 </pre></li></ul>
<p>
<ul>
<li><b>DELETE</b> (Die Liste der Indexe auf der Tabelle wird angehaengt; diese Indexe muessen mit gewartet werden, d.h. die jeweiligen Eintraege sind dort von der RunTime zu entfernen.) <pre>
 DeleteStmt
     |
  Sources - Table - <em>Index</em> - <em>Index</em> - ...
     |
 WhereClause - &lt;where-clause&gt;
 </pre></li></ul>
<p>
<ul>
<li><b>SELECT</b> (bleibt unveraendert) <pre>
 SelectStmt
     |
 Projections - Column - Column - ...
     |
 Sources - Table - Table - Table - ...
     |
 WhereClause - &lt;where-clause&gt;
 </pre></li></ul>
<p>
<ul>
<li><b>COMMIT</b> (bleibt unveraendert) <pre>
 CommitStmt
 </pre></li></ul>
<p>
<ul>
<li><b>ROLLBACK</b> (bleibt unveraendert) <pre>
 RollbackStmt
 </pre></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>accessPlan</em>&nbsp;</td><td>zu annotierender Plan </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00180">180</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_optimizer_8cpp-source.html#l00231">annotateTableNode()</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, and <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d1" doxytag="DbjOptimizer::annotateTableNode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::annotateTableNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan_table.html">DbjAccessPlanTable</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>plan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Annotiere Table Knoten. 
<p>
Annotiere einen "Table" Knoten im Zugriffsplan mit den Indexen. Dabei wird unter den "Table"-Knoten eine Liste von "Index"-Knoten gehaengt. Jeder Knoten in dieser Liste repraesentiert einen Index, der auf der Tabelle existiert. Bei einer DROP TABLE Anweisung werden die Indexe mit geloescht, und beim INSERT bzw. DELETE muessen die Datenmodifikationen in jeden der Indexe eingespielt werden.<p>
Es ist zu beachten, dass der Index-Knoten <b>nur</b> mit einem Integer-Wert initialisiert wird: der Index-ID. Es wird <b>nicht</b> der externe Indexname gesetzt.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>plan</em>&nbsp;</td><td>zu annotierender Knoten im Plan </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00231">231</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_table_8cpp-source.html#l00280">DbjTable::getIndex()</a>, <a class="el" href="_dbj_index_8cpp-source.html#l00026">DbjIndex::getIndexId()</a>, <a class="el" href="_dbj_table_8cpp-source.html#l00260">DbjTable::getNumIndexes()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00471">DbjAccessPlanTable::getTableDescriptor()</a>, <a class="el" href="_dbj_types_8hpp-source.html#l00125">IndexId</a>, <a class="el" href="_dbj_access_plan_8cpp-source.html#l00554">DbjAccessPlanIndex::setIndexDescriptor()</a>, and <a class="el" href="_dbj_types_8hpp-source.html#l00070">Uint32</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d8" doxytag="DbjOptimizer::eliminateConstantPredicates" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::eliminateConstantPredicates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="class_dbj_optimizer.html#y3">TruthValue</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>truthValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Eliminiere Konstante Praedikate. 
<p>
Durchsuche alle Praedikate in der angegebenen Liste und ueberpruefe, welche Praedikate konstante Wahrheitswerte haben (auf Grund dessen, dass sie nur Konstanten vergleichen). Wird ein solches Praedikat gefunden, so wird es ausgewertet (ausgenommen "[NOT] LIKE"), und anschliessend aus der Liste entfernt. Dabei wird sichergestellt, dass mindestens 1 Praedikat in der Liste verbleibt, so dass anschliessend <a class="el" href="class_dbj_optimizer.html#d3">DbjOptimizer::eliminateExcessiveNesting()</a> aufraeumen kann.<p>
Die Methode geht davon aus, dass zuvor bereits AND/OR-Verknuepfungen geschachtelt und alle Negationen abgearbeitet wurden.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>erstes Praedikate in der aktuellen Ebene im Baum, die untersucht werden soll </td></tr>
    <tr><td></td><td valign=top><em>truthValue</em>&nbsp;</td><td>Wahrheitswert der gesamten Ebene </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00924">924</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="class_dbj_optimizer.html#y3y1">AlwaysFalse</a>, <a class="el" href="class_dbj_optimizer.html#y3y0">AlwaysTrue</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00022">AND</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l01070">getTruthValue()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00023">OR</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, <a class="el" href="_dbj_types_8hpp-source.html#l00042">Uint8</a>, and <a class="el" href="class_dbj_optimizer.html#y3y2">Undetermined</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d3" doxytag="DbjOptimizer::eliminateExcessiveNesting" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::eliminateExcessiveNesting           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>predicate</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Eliminiere Schachtelungen. 
<p>
Die WHERE-Klausel kann unnoetige Schachtelungen auf Grund der moeglichen Klammerungen enthalten. So resultiert beispielsweise ein Predikat der Form "(((a = b) AND (c = d)) AND e = f)" in folgenden Fragment: <pre>
 Predicate
    |
 Predicate - AND - Predicate (*)
    |                 |
    |               e = f
    |
 Predicate - AND - Predicate
    |                 |
 Predicate(*)      Predicate(*)
    |                 |
  a = b             c = d
     *</pre> Es ist offensichtlich, dass die mit (*) markierten Schachtelungsebenen unnötig sind. Diese Methode analysiert daher die WHERE-Klausel und entfernt die entsprechenden "Predicate" Knoten. In obigen Beispiel wuerde das Ergebnis so aussehen: <pre>
 Predicate
    |
 Predicate - AND - Predicate - AND - Predicate
    |                 |                 |
  a = b             c = d             e = f
     *</pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>Zeiger auf einen "Predicate"-Knoten in der, der analysiert werden soll (und bei Bedarf entfernt wird) </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00441">441</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_optimizer_8cpp-source.html#l00022">AND</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00222">DBJ_TRACE_DATA1</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00226">DBJ_TRACE_DATA2</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00238">DBJ_TRACE_STRING</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00023">OR</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, and <a class="el" href="_dbj_types_8hpp-source.html#l00042">Uint8</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d11" doxytag="DbjOptimizer::findIndexForPredicate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::findIndexForPredicate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *&nbsp;</td>
          <td class="mdname" nowrap> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="class_dbj_access_plan_index.html">DbjAccessPlanIndex</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>indexNode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>bool &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finde Index fuer Praedikat. 
<p>
Fuer das angegebene Praedikat wird ueberprueft, ob es eventuell einen Index gibt, der ausgenutzt werden kann. Existiert ein solcher Index, so wird der Knoten "indexNode" fuer den Zugriffsplan erzeugt und zurueckgegeben. Ist bereits ein "indexNode" vorhanden, so koennen zwei Faelle eintreten:<ol>
<li>der aktuelle Index und "indexNode" bezeichnen den gleichen Index - also wird das aktuelle Praedikat zu "indexNode" mit hinzugefuegt</li><li>der aktuelle Index ist ein anderer - wir ignorieren den aktuellen Index</li></ol>
<p>
Indexe koennen nicht genutzt werden, wenn:<ul>
<li>zwei Spalten verglichen werden</li><li>[NOT] LIKE verwendet wird</li><li>IS [NOT] NULL verwendet wird</li><li>kein "&lt;&gt;" Operator genutzt wird</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>das zu analysierende Praedikat </td></tr>
    <tr><td></td><td valign=top><em>indexNode</em>&nbsp;</td><td>Referenz auf den zu erzeugenden oder zu modifizierenden "indexNode" fuer den Zugriffsplan </td></tr>
    <tr><td></td><td valign=top><em>used</em>&nbsp;</td><td>Indikator, ob dieses Praedikat in den Index einfloss </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l01326">1326</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="group__datatypes.html#gga1a35">BTree</a>, <a class="el" href="_dbj_index_key_8hpp-source.html#l00032">DbjIndexKey::dataType</a>, <a class="el" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a4">DBJ_NOT_FOUND_WARN</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00218">DBJ_TRACE_ACTIVE</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00231">DBJ_TRACE_DATA3</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00238">DBJ_TRACE_STRING</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_string_8hpp-source.html#l00048">DbjStringCompare()</a>, <a class="el" href="_dbj_string_8hpp-source.html#l00102">DbjStringConcat()</a>, <a class="el" href="_dbj_catalog_manager_8cpp-source.html#l00734">DbjCatalogManager::getIndexDescriptor()</a>, <a class="el" href="_dbj_index_8cpp-source.html#l00043">DbjIndex::getIndexName()</a>, <a class="el" href="_dbj_catalog_manager_8hpp-source.html#l00091">DbjCatalogManager::getInstance()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00188">DbjAccessPlan::getIntData()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00698">DbjAccessPlanIndex::getStartKey()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00707">DbjAccessPlanIndex::getStopKey()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_access_plan_8cpp-source.html#l00417">DbjAccessPlanColumn::getTableDescriptor()</a>, <a class="el" href="group__datatypes.html#gga1a36">Hash</a>, <a class="el" href="_dbj_table_8cpp-source.html#l00306">DbjTable::hasIndexOfType()</a>, <a class="el" href="_dbj_types_8hpp-source.html#l00125">IndexId</a>, <a class="el" href="group__datatypes.html#gga0a33">INTEGER</a>, <a class="el" href="_dbj_index_key_8hpp-source.html#l00034">DbjIndexKey::intKey</a>, <a class="el" href="_dbj_access_plan_8cpp-source.html#l00554">DbjAccessPlanIndex::setIndexDescriptor()</a>, <a class="el" href="_dbj_access_plan_8cpp-source.html#l00575">DbjAccessPlanIndex::setStartKey()</a>, <a class="el" href="_dbj_access_plan_8cpp-source.html#l00595">DbjAccessPlanIndex::setStopKey()</a>, <a class="el" href="_dbj_types_8hpp-source.html#l00070">Uint32</a>, <a class="el" href="group__datatypes.html#gga0a32">VARCHAR</a>, and <a class="el" href="_dbj_index_key_8hpp-source.html#l00037">DbjIndexKey::varcharKey</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d10" doxytag="DbjOptimizer::findIndexScans" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::findIndexScans           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tableList</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finde moegliche Index-Scans. 
<p>
Diese Methode ueberprueft alle Tabellen in der FROM-Klausel einer SELECT-Anweisungen, und ob es Praedikate gibt, die ausschliesslich auf den einzelnen Tabellen operieren. Ist das der Fall, so wird getestet, ob mindestens eines der Praedikate durch einen Index-Scan abgehandelt werden koennte. Ist das der Fall, so wird ein "Index"-Knoten in den Baum eingefuegt. Gibt es mehrere solcher qualifizierender Praedikate, so wird das erste gefundene verwendet.<p>
Bei der Suche wird beachtet, dass Hash-Indexe keine Bereichsanfragen zulassen. Weiterhin koennen sich mehrere Praedikate fuer ein und denselben B-Baum-Index qualifizieren. Soweit wie moeglich werden diese Praedikate dann zusammengefasst, so dass beispielsweise eine Ober- und Untergrenze fuer den Index-Scan genutzt werden kann. Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l01232">1232</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l01326">findIndexForPredicate()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, and <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d7" doxytag="DbjOptimizer::getAccessedTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::getAccessedTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *&nbsp;</td>
          <td class="mdname" nowrap> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ermittle genutzte Tabellen. 
<p>
Ermittle den "Table"-Knoten im Plan, der von allen Spalten im aktuellen Praedikat verwendet wird. Greift ein Praedikat auf mehrere Tabellen zu (das ist z.B. bei Join-Bedingungen der Fall), so wird eine Warnung <code>DBJ_OPT_PREDICATE_ON_MULTIPLE_TABLES_WARN</code> zurueckgegeben. Nutzt ein Praedikat keine Tabelle (Vergleich von zwei Konstanten), so wird ein NULL-Zeiger zurueckgegeben.<p>
Da ein Praedikat wiederum aus andere Praedikaten bestehen kann, wird rekursiv der gesamte Teilbaum durchsucht.<p>
Hinweis: alle "Column"-Knoten haben bereits einen Verweis auf den entsprechenden "Table"-Knoten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>zu analysierendes Praedikat </td></tr>
    <tr><td></td><td valign=top><em>table</em>&nbsp;</td><td>Zeiger auf den "Table"-Knoten, zu dem das Praedikat gehoert </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00851">851</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_error_codes_8hpp.html#a107a30">DBJ_OPT_PREDICATE_ON_MULTIPLE_TABLES_WARN</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, and <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d9" doxytag="DbjOptimizer::getTruthValue" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::getTruthValue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> const *&nbsp;</td>
          <td class="mdname" nowrap> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="class_dbj_optimizer.html#y3">TruthValue</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>truthValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ermittle den Wahrheitswert eines simplen Praedikats. 
<p>
Ermittle, ob das angegebene Praedikat immer "wahr" oder "falsch" ist, oder ob das Ergebnis erst zur Laufzeit bekannt ist. Das erwartete Praedikat muss in der Form "&lt;expression&gt; - Comparison - &lt;expression&gt;" sein, also keinen "Predicate"-Knoten mehr enthalten.<p>
Diese Methode wird dazu verwendet, Konstante Praedikate zu finden und aus dem Zugriffsplan zu entfernen.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>Praedikat, fuer das der Wahrheitswert ermittelt wird </td></tr>
    <tr><td></td><td valign=top><em>truthValue</em>&nbsp;</td><td>Wahrheitswert des Praedikats </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l01070">1070</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="class_dbj_optimizer.html#y3y1">AlwaysFalse</a>, <a class="el" href="class_dbj_optimizer.html#y3y0">AlwaysTrue</a>, <a class="el" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="group__datatypes.html#gga2a41">DBJ_LARGER_STRING</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="group__datatypes.html#gga2a40">DBJ_SMALLER_STRING</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_types_8hpp-source.html#l00198">DbjCompareResult</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_string_8hpp-source.html#l00048">DbjStringCompare()</a>, <a class="el" href="_dbj_string_8hpp-source.html#l00074">DbjStringCompareCase()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00188">DbjAccessPlan::getIntData()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00590">DbjAccessPlanColumn::getTableNode()</a>, and <a class="el" href="class_dbj_optimizer.html#y3y2">Undetermined</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d13" doxytag="DbjOptimizer::getTupleCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::getTupleCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan_table.html">DbjAccessPlanTable</a> const *&nbsp;</td>
          <td class="mdname" nowrap> <em>tableNode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group__int__datatypes.html#ga15">Uint32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tupleCount</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hole Anzahl der Tupel. 
<p>
Bestimme die Anzahl der Tupel einer Tabelle. Der uebergebene Knoten im Zugriffsplan ist dabei der Tabellen-Knoten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>tableNode</em>&nbsp;</td><td>Tabellen-Knoten, fuer den die Tupel-Anzahl zu ermitteln ist </td></tr>
    <tr><td></td><td valign=top><em>tupleCount</em>&nbsp;</td><td>Referenz auf die Anzahl der Tupel </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l01667">1667</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00471">DbjAccessPlanTable::getTableDescriptor()</a>, <a class="el" href="_dbj_table_8hpp-source.html#l00090">DbjTable::getTupleCount()</a>, and <a class="el" href="_dbj_types_8hpp-source.html#l00070">Uint32</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d2" doxytag="DbjOptimizer::nestAndOrCombinations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::nestAndOrCombinations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>predicate</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loese AND/OR auf. 
<p>
Die logischen Verknuepfungen AND bzw. OR koennen gemeinsam in einem Praedikat auftreten, wobei der AND-Operator Vorrang hat. Als Beispiel kann folgendes in einer WHERE-Klausel vorkommen: <pre>
 pred1 AND pred2 OR pred3 OR ( pred4 AND pred5 )
     *</pre><p>
Diese Methode analysiert alle Praedikate in der WHERE-Klausel und schachtelt gemischte AND/OR-Verknuepfungen entsprechnd. Bei dem oben gezeigten Beispiel wird folgende Schachtelung gebildet. <pre>
 Predicate - OR - Predicate - OR - Predicate
   |                 |                |
   |               pred3           pred4 - AND pred5
   |
 pred1 - AND - pred2
     *</pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicate</em>&nbsp;</td><td>aktuelle Predikatliste, die analysiert und aufgeloest werden soll </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00302">302</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_optimizer_8cpp-source.html#l00022">AND</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00222">DBJ_TRACE_DATA1</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00023">OR</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, and <a class="el" href="_dbj_types_8hpp-source.html#l00042">Uint8</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="DbjOptimizer::optimize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::optimize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>accessPlan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimiere Zugriffsplan. 
<p>
Optimiere den gegebenen Zugriffsplan. Das Optimieren besteht hierbei aus zwei Schritten:<ol>
<li>annotiere den Plan (siehe <a class="el" href="class_dbj_optimizer.html#d0">DbjOptimizer::annotate</a>)</li><li>optimiere den Plan für DELETE und SELECT-Anweisungen</li></ol>
<p>
Es werden nur DELETE und SELECT-Anweisungen optimiert, da nur in diesen Faellen auf Grund der WHERE-Klausel komplexer Anweisungen entstehen koennen. Alle anderen Anweisungen sind eher simpel und es wird nur die Annotation durchgefuehrt, d.h. es werden die Informationen ueber die existierenden (oder zu erzeugenden) Indexe in den Zugriffsplan eingefuegt.<p>
Das Ergebnis der Annotation ist fuer der Methode <a class="el" href="class_dbj_optimizer.html#d0">DbjOptimizer::annotate</a> dokumentiert. Im folgenden ist jeweils ein Beispiel fuer das Ergebnis einer annotierten und optimierten DELETE bzw. SELECT-Anweisung gezeigt.<p>
<ul>
<li><b>DELETE</b> (Zusaetzlich zur Annotation, bei der die Liste der Indexe auf der Tabelle eingehaengt wurde, wird unter Umstaenden ein Knoten vom Typ "Index" als Nachbar an den "Table" Knoten angehaengt. Ist dieser zusaetzliche Knoten vorhanden, so beschreibt er, dass ueber den entsprechenden Index ein Scan ausgefuehrt werden soll - gefolgt von einem weiteren Filtern - um die zu loeschenden Tupel der Tabelle zu finden.) <pre>
 DeleteStmt
     |
  Sources - Table - Index - Index - ...
     |        |
     |      <em>Index</em>
     |        |
     |      <em>Predicate - LogicOperation - Predicate - ...</em>
     |        |                            |
     |        |                          <em>Expression - Comparison - Expression</em>
     |        |
     |      <em>Expression - Comparison - Expression</em>
     |
 WhereClause - &lt;where-clause&gt;
 </pre></li></ul>
<p>
<ul>
<li><b>SELECT</b> (Es werden Praedikate, die nur auf einer Tabelle arbeiten, an die entsprechenden "Table"-Knoten gehaengt und gleichzeitig aus der "WhereClause" entfernt. Dies bedeutet fuer die RunTime, dass die Tupel der Tabelle zuerst zu filtern sind, bevor sie in einen Join eingehen. Soll auf die Tabelle mittels IndexScan zugegriffen werden, so wird - wie bei der zweiten Tabelle gezeigt - ein Index-Knoten als Sohn angehaengt. Dieser Knoten beschreibt, welcher Index gescannt werden soll und in welchem Bereich. Optional koennen unter diesem Index-Knoten noch weitere Praedikate aufgefuehrt werden, die auf den Ergebnis-Tupeln des Index-Scans ausgewertet werden bevor sie in einen Join einfliessen. <pre>
 SelectStmt
     |
 Projections - Column - Column - ...
     |
 Sources - Table - Table - Table - ...
     |       |       |
     |       |     <em>Index</em>
     |       |       |
     |       |     <em>Predicate</em>
     |       |       |
     |       |     <em>Expression - Comparison - Value</em>
     |       |
     |     <em>Predicate - LogicOperation - Predicate</em>
     |       |                            |
     |       |                          <em>Expression - Comparison - Value</em>
     |       |
     |     <em>Expression - Comparison - Expression</em>
     |
 WhereClause - &lt;where-clause&gt;
 </pre></li></ul>
<p>
Hinweis: Im Ergebnis enthaelt der Plan keine "Negation"-Knoten mehr in der WHERE-Klausel!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>accessPlan</em>&nbsp;</td><td>validierter Zugriffsplan, der optimiert wieder zurueckgegeben wird </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00027">27</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="class_dbj_optimizer.html#y3y1">AlwaysFalse</a>, <a class="el" href="class_dbj_optimizer.html#y3y0">AlwaysTrue</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00180">annotate()</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a31">DBJ_OPT_EMPTY_RESULT_SET_WARN</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00924">eliminateConstantPredicates()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00441">eliminateExcessiveNesting()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l01232">findIndexScans()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00302">nestAndOrCombinations()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00562">removeAllNegations()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00739">sortPredicatesToTables()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l01590">sortTableList()</a>, <a class="el" href="_dbj_optimizer_8hpp-source.html#l00138">TruthValue</a>, and <a class="el" href="class_dbj_optimizer.html#y3y2">Undetermined</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d4" doxytag="DbjOptimizer::removeAllNegations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::removeAllNegations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>predicates</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Entferne Negationen. 
<p>
Entferne alle Negationen aus der WHERE-Klausel indem die entsprechenden Vergleichsoperatoren negiert werden.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicates</em>&nbsp;</td><td>Zeiger auf den Startknoten der WHERE-Klausel (Typ "WhereClause") </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00562">562</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00622">resolveNegation()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, and <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d5" doxytag="DbjOptimizer::resolveNegation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::resolveNegation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>negation</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loese eine Negation auf. 
<p>
Loese eine einzelne Negationen aus der WHERE-Klausel auf, indem folgendes getan wird:<ol>
<li>Wird ein Teilbaum negiert, der mehrere Praedikate logisch verknuepft, so werden die Verknuepfungen negiert und die einzelnen Unterpraedikate negiert.</li><li>Wird nur ein einzelnes Praedikat negiert, so wird einfach der Vergleichsoperator umgekehrt.</li></ol>
<p>
Der urspruengliche "Negation"-Knoten wird bei dieser Operation nicht aus dem Baum entfernt. Dies ist die Aufgabe des Aufrufers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>negation</em>&nbsp;</td><td>Zeiger auf den "Negation"-Knoten, der aufgeloest werden soll </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00622">622</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="group__datatypes.html#gga2a38">DBJ_EQUALS</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_string_8hpp-source.html#l00048">DbjStringCompare()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, and <a class="el" href="_dbj_access_plan_8cpp-source.html#l00039">DbjAccessPlan::setStringData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d6" doxytag="DbjOptimizer::sortPredicatesToTables" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::sortPredicatesToTables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>predicates</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sortiere Praedikate zu Tabellen. 
<p>
Diese Methode analysiert alle Praedikate in der WHERE-Klausel einer SELECT-Anweisung und bestimmt, auf welchen Tabellen das jeweilige Praedikat operiert. Alle Praedikate, die nur auf genau einer Tabelle operieren, werden - wie in <a class="el" href="class_dbj_optimizer.html#a0">DbjOptimizer::optimize</a> erlaeutert - an die entsprechende Tabelle angehaengt. Ein so angehaengtes Praedikat wird aus der WHERE-Klausel entfernt, damit es nicht 2x evaluiert wird.<p>
Fuer diesen Optimierungsschritt setzen wir voraus, dass alle Praedikate mit AND verknuepft sind - zumindest auf der ersten Ebene. In geklammerten Praedikaten duerfen auch OR-Verknuepfungen verwendet werden.<p>
Der Sinn dieser Optimierung ist es, dass Selektionen vor Join-Operationen ausgefuehrt werden, wenn dies moeglich ist.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>predicates</em>&nbsp;</td><td>Zeiger auf die Liste der auszuwertenden Praedikate (zeigt auf den ersten "Predicate"-Knoten) </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00739">739</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_access_plan_8hpp-source.html#l00332">DbjAccessPlan::addSon()</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a30">DBJ_OPT_PREDICATE_ON_MULTIPLE_TABLES_WARN</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l00851">getAccessedTable()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00158">DbjAccessPlan::getParent()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00151">DbjAccessPlan::getSon()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00172">DbjAccessPlan::getStringData()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00284">DbjAccessPlan::setSon()</a>, and <a class="el" href="_dbj_access_plan_8cpp-source.html#l00039">DbjAccessPlan::setStringData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d12" doxytag="DbjOptimizer::sortTableList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="_dbj_error_codes_8hpp.html#a107">DbjErrorCode</a> DbjOptimizer::sortTableList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_dbj_access_plan.html">DbjAccessPlan</a> *&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tableList</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sortiert die Tabellen im SELECT. 
<p>
Gehe alle Tabellen in der FROM-Klausel einer SELECT-Anweisung durch und entscheide anhand der Tupelanzahl der einzelnen Tabellen ueber die Ausfuehrungsreihenfolge in den Joins (nested loop).<p>
Die Methode erhaelt den "Sources" Knoten des Zugriffsplans als Eingabeparameter und sortiert die an ihn angehaengten Tabellen-Knoten. Der uebergebene "Sources"-Knoten wird anschliessend unveraendert (evtl. bis auf seinen "Next" Verweis) zurueckgegeben.<p>
Intern werden einfach alle "Table" Knoten ausgehaengt, und anschliessend wird die Liste jeweils durchlaufen, um den Tabellen-Knoten mit der geringsten Anzahl an Tupeln zu finden. Dieser Knoten wird aus der Liste entfernt und an den urspruenglichen "Sources"-Knoten angehaengt, bevor der Prozess wieder beim Suchen weitergeht - bis alle Tabellen der Liste prozessiert wurden.<p>
Diese Methode sollte nur dann aufgerufen werden, wenn die einzelnen Tabellen keine einschraenkenden Praedikate zugeordnet bekamen.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>tableList</em>&nbsp;</td><td>zu sortierender Liste der Tabellen </td></tr>
  </table>
</dl>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l01590">1590</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.
<p>
References <a class="el" href="_dbj_access_plan_8hpp-source.html#l00307">DbjAccessPlan::addNext()</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a2">DBJ_INTERNAL_FAIL</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a3">DBJ_PARAMETER_FAIL</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00256">DBJ_SET_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp.html#a107a1">DBJ_SUCCESS</a>, <a class="el" href="_dbj_trace_8hpp-source.html#l00212">DBJ_TRACE_ENTRY</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00347">DBJ_TRACE_ERROR</a>, <a class="el" href="_dbj_error_codes_8hpp-source.html#l00037">DbjErrorCode</a>, <a class="el" href="_dbj_error_8hpp-source.html#l00235">DbjGetErrorCode()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00136">DbjAccessPlan::getNext()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00127">DbjAccessPlan::getNodeType()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00143">DbjAccessPlan::getPrevious()</a>, <a class="el" href="_dbj_optimizer_8cpp-source.html#l01667">getTupleCount()</a>, <a class="el" href="_dbj_access_plan_8hpp-source.html#l00260">DbjAccessPlan::setNext()</a>, and <a class="el" href="_dbj_types_8hpp-source.html#l00070">Uint32</a>.    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="v0" doxytag="DbjOptimizer::AND" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="group__int__datatypes.html#ga3">Uint8</a> <a class="el" href="class_dbj_optimizer.html#v0">DbjOptimizer::AND</a> = 0x01<code> [static, private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flag fuer "AND"-Verknuepfung. 
<p>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00022">22</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.    </td>
  </tr>
</table>
<a class="anchor" name="v1" doxytag="DbjOptimizer::OR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="group__int__datatypes.html#ga3">Uint8</a> <a class="el" href="class_dbj_optimizer.html#v1">DbjOptimizer::OR</a> = 0x02<code> [static, private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flag fuer "OR"-Verknuepfung. 
<p>
Definition at line <a class="el" href="_dbj_optimizer_8cpp-source.html#l00023">23</a> of file <a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_dbj_optimizer_8hpp-source.html">DbjOptimizer.hpp</a><li><a class="el" href="_dbj_optimizer_8cpp-source.html">DbjOptimizer.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jul 4 15:40:34 2005 for Jenas Datenbanksystem 'System J' by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
